# 기본 정렬 알고리즘 1(선택, 삽입, 버블)
</br>
</br>

정렬 알고리즘이란 n개의 데이터가 입력으로 주어졌을 때, 이를 사용자가 정한 기준에 따라 정렬하여 출력하는 것입니다.  
따라서 주로 사용하는 연산은 **비교**, **교환**등이 있습니다.  
정렬 알고리즘의 종류는 굉장히 다양한데, 이에 따라 수행시간도 천차만별입니다.  
또한 같은 정렬 알고리즘을 사용하더라도 입력 데이터의 종류에 따라 수행시간이 달라지기 때문에 적절한 정렬을 사용해야 합니다.
</br>

![시간복잡도](https://user-images.githubusercontent.com/69297345/106095000-5b41b480-6176-11eb-8a11-6d1086d1bb9a.png)
</br>
</br>
</br>

## 1.선택 정렬(Selection Sort)
선택 정렬은 현재 위치에 들어갈 값을 찾은 후 집어넣는 정렬입니다.  
첫번째 자리에 가장 작은 데이터를 집어넣고, 두번째 자리에는 나머지 데이터 중에서 가장 작은 데이터를 집어넣습니다. 이와같은 로직을 반복하다 보면 오름차순 정렬이 됩니다.  
</br>

데이터를 비교하면서 자리를 찾기때문에 **비교 정렬**이며 정렬의 대상이 되는 데이터 외에 추가적인 메모리가 필요하지 않기 때문에 **제자리 정렬**에 해당됩니다.
</br>

n-1개, n-2개, ... , 1개의 비교를 반복하기 때문에 시간복잡도는 **O(n^2)** 이 됩니다.
</br>
</br>

### 1.1 선택 정렬 구현 코드
```java
	private void selectionSort(int[] arr, int size) {
		for(int i=0; i<size-1; i++) {
			int minIdx = i;
			
			for(int j=i+1; j<size; j++) {
				if(arr[j] < arr[minIdx])
					minIdx = j;
			}
		
			swap(arr, minIdx, i);
		}
	}
```
</br>
</br>

### 1.2 정리
- 선택 정렬은 구현이 간단하고, 추가적인 메모리는 사용하지 않기때문에 메모리 소비가 적다는 장점이 있습니다.
- 하지만 시간복잡도가 O(n^2)으로 많은 시간이 소요되고, 불안정 정렬이기 때문에 정렬을 하면서 초기 배열 순서가 흐트러지게 됩니다. 예를들어 학생의 학번 오름차순으로 정렬되어있는 배열을 성적순으로 정렬하되, 성적이 같으면 학번순으로 오름차순이 되도록 하고싶을 때, 선택정렬을 사용하게 되면 기존의 학번 오름차순은 뒤섞이게 될 수 있습니다.
</br>
</br>
</br>

## 2. 삽입 정렬(Insertion Sort)
삽입 정렬은 현재 위치의 데이터의 자리를 찾은 후, 그 자리에 삽입하는 정렬입니다.  
삽입 정렬은 두번째 인덱스부터 시작하며 현재 위치의 데이터보다 큰 값은 하나씩 밀고, 작은 값을 만나면 그 바로 뒤에 삽입합니다.  
이를 반복하게되면 정렬된 데이터가 만들어집니다.  
</br>

삽입 정렬도 선택정렬과 마찬가지로 **비교 정렬**, **제자리 정렬**이며, 시간복잡도는 **O(n^2)** 입니다.
</br>
</br>

### 2.1 삽입 정렬 구현 코드
```java
	private void insertionSort(int[] arr, int size) {
		for(int i=1; i<size; i++) { // 두번째 인덱스부터 시작
			int cur = arr[i];
			int j = i-1;
			while(j>=0 && arr[j]>cur) {
				arr[j+1] = arr[j];
				j--;
			}
			arr[j+1] = cur;
		}
	}
```
</br>
</br>

### 2.2 정리
- 삽입 정렬은 선택, 버블정렬과 다르게 탐색을 거듭할수록 그 범위가 점점 넓어집니다.  
- 선택정렬과 마찬가지로 추가적인 메모리가 필요하지 않기때문에 메모리 소비가 적습니다.
- 삽입 정렬의 시간 복잡도는 O(n^2)이지만 부분적으로 정렬된 배열에 대해서는 성능을 개선할 수 있습니다. 특히 입력으로 완전히 **정렬되어있는 배열**이 들어올 경우, 시간 복잡도를 **O(n)** 까지 향상시킬 수 있습니다.
</br>
</br>

### 2.3 삽입 정렬의 최적화
삽입 정렬에서의 최적화는 원래 있던 값들은 모두 정렬되어있는 상태에서 새로운 데이터가 들어온다고 가정할 때, 새로 들어온 데이터보다 작은 값을 만나게 되면 탐색을 멈추고 그 뒤에 데이터를 추가하는 것입니다.  
이러한 최적화를 하게되면 시간복잡도를 **O(N)** 으로 향상시킬 수 있습니다.


</br>
</br>
</br>

## 3. 버블 정렬(Bubble Sort)
버블 정렬이란 **인접한 두 인덱스**를 비교하여 교환하는 정렬입니다.  
처음 루프를 돌면 가장 큰 원소가 마지막 인덱스에 위치하게 되고, 이러한 로직을 n-1번 반복하면 정렬된 데이터가 만들어집니다.
</br>

선택, 삽입정렬과 마찬가지로 **비교 정렬**, **제자리 정렬**이며, 시간복잡도는 **O(n^2)** 입니다.
</br>
</br>

### 3.1 버블 정렬 구현 코드
```java
	private void bubbleSort(int[] arr, int size) {
		for(int i=0; i<size-1; i++) { // 반복 횟수를 나타냄
			for(int j=i; j<size-i-1; j++) {
				if(arr[j] > arr[j+1])
					swap(arr,j,j+1);
			}
		}
	}
```
</br>
</br>
